
byte/%.cmi: %.mli
	$(BYTE_CAMLC) $(BYTE_COMPFLAGS) -o $@ -c $<

byte/%.cmo: %.ml
	$(BYTE_CAMLC) $(BYTE_COMPFLAGS) -o $@ -c $<

byte/%.cmx: %.ml
	$(BYTE_CAMLOPT) $(BYTE_COMPFLAGS) -o $@ -c $<

asmcomp/byte:
	mkdir -p $@

asmcomp/byte/%.ml: asmcomp/$(BYTE_ARCH)/%.ml | asmcomp/byte
	cp $< $@

asmcomp/byte/%.mli: asmcomp/%.mli | asmcomp/byte
	cp $< $@

asmcomp/byte/%.mlp: asmcomp/$(BYTE_ARCH)/%.mlp | asmcomp/byte
	cp $< $@

asmcomp/byte/emit.ml: asmcomp/byte/emit.mlp boot_build/tools/cvt_emit
	$(CAMLRUN) boot_build/tools/cvt_emit < $< > $@ \
	|| { rm -f $@; exit 2; }

byte_arch: $(addprefix asmcomp/byte/, \
	arch.ml emit.ml emit.mli proc.ml proc.mli selection.ml selection.mli \
	reload.ml reload.mli scheduling.ml scheduling.mli )

partialclean::
	rm -rf asmcomp/byte

beforedepend:: byte_arch

.PHONY: byte_arch

$(BYTE_ALL) $(BYTE_ALL:.cmo=.cmi): stdlib/byte/stdlib.cma
$(BYTE_ALL:.cmo=.cmx): stdlib/byte/stdlib.cmxa

byte/compilerlibs/ocamlcommon.cma: $(BYTE_COMMON) | byte/compilerlibs
	$(BYTE_CAMLC) -a -o $@ $(BYTE_COMMON)

byte/compilerlibs/ocamlcommon.cmxa: $(BYTE_COMMON:.cmo=.cmx) | byte/compilerlibs
	$(BYTE_CAMLOPT) -a -o $@ $(BYTE_COMMON:.cmo=.cmx)


byte/compilerlibs/ocamlbytecomp.cma: $(BYTE_BYTECOMP) | byte/compilerlibs
	$(BYTE_CAMLC) -a -o $@ $(BYTE_BYTECOMP)

byte/compilerlibs/ocamlbytecomp.cmxa: $(BYTE_BYTECOMP:.cmo=.cmx) | byte/compilerlibs
	$(BYTE_CAMLOPT) -a -o $@ $(BYTE_BYTECOMP:.cmo=.cmx)


byte/compilerlibs/ocamltoplevel.cma: $(BYTE_TOPLEVEL) | byte/compilerlibs
	$(BYTE_CAMLC) -a -o $@ $(BYTE_TOPLEVEL)

byte/compilerlibs/ocamltoplevel.cmxa: $(BYTE_TOPLEVEL:.cmo=.cmx) | byte/compilerlibs
	$(BYTE_CAMLOPT) -a -o $@ $(BYTE_TOPLEVEL:.cmo=.cmx)


byte/compilerlibs/ocamloptcomp.cma: $(BYTE_ASMCOMP) | byte/compilerlibs
	$(BYTE_CAMLC) -a -o $@ $(BYTE_ASMCOMP)

byte/compilerlibs/ocamloptcomp.cmxa: $(BYTE_ASMCOMP:.cmo=.cmx) | byte/compilerlibs
	$(BYTE_CAMLOPT) -a -o $@ $(BYTE_ASMCOMP:.cmo=.cmx)


byte/ocamlc.opt: byte/compilerlibs/ocamlcommon.cmxa \
	         byte/compilerlibs/ocamlbytecomp.cmxa \
	         $(BYTE_BYTESTART:.cmo=.cmx) stdlib/byte/std_exit.cmx \
	         asmrun/libasmrun.a
	$(BYTE_CAMLOPT) $(LINKFLAGS) -o $@ \
	   byte/compilerlibs/ocamlcommon.cmxa \
	   byte/compilerlibs/ocamlbytecomp.cmxa \
	   $(BYTE_BYTESTART:.cmo=.cmx)

byte/ocamlopt.opt: byte/compilerlibs/ocamlcommon.cmxa \
	           byte/compilerlibs/ocamloptcomp.cmxa \
	           $(BYTE_OPTSTART:.cmo=.cmx) stdlib/byte/std_exit.cmx \
	           asmrun/libasmrun.a
	$(BYTE_CAMLOPT) $(LINKFLAGS) -o $@ \
	   byte/compilerlibs/ocamlcommon.cmxa \
	   byte/compilerlibs/ocamloptcomp.cmxa \
	   $(BYTE_OPTSTART:.cmo=.cmx)

byte/ocamlc: byte/compilerlibs/ocamlcommon.cma \
	           byte/compilerlibs/ocamlbytecomp.cma \
	           $(BYTE_BYTESTART) stdlib/byte/std_exit.cmo
	$(BYTE_CAMLC) $(LINKFLAGS) -compat-32 -o $@ \
	   byte/compilerlibs/ocamlcommon.cma \
	   byte/compilerlibs/ocamlbytecomp.cma \
	   $(BYTE_BYTESTART)

#FIXME: missing -compat-32
byte/ocamlopt: byte/compilerlibs/ocamlcommon.cma \
	             byte/compilerlibs/ocamloptcomp.cma \
	             $(BYTE_OPTSTART) stdlib/byte/std_exit.cmo
	$(BYTE_CAMLC) $(LINKFLAGS) -o $@ \
	   byte/compilerlibs/ocamlcommon.cma \
	   byte/compilerlibs/ocamloptcomp.cma \
	   $(BYTE_OPTSTART)


stdlib/byte/stdlib.cma: $(CAMLRUN) boot_build/ocamlc
	$(MAKE) -C stdlib byte/stdlib.cma

# Depends on stdlib.cma because .cmi are build using ocamlc maybe add a
# stdlib/all_cmi target that would also allow allow more parallelism
stdlib/byte/stdlib.cmxa: $(CAMLRUN) boot_build/ocamlopt \
                                      stdlib/byte/libasmrun.a \
                                      stdlib/byte/stdlib.cma
	$(MAKE) -C stdlib byte/stdlib.cmxa

stdlib/byte/std_exit.cmo: $(CAMLRUN) boot_build/ocamlc
	$(MAKE) -C stdlib byte/std_exit.cmo

stdlib/byte/std_exit.cmx: $(CAMLRUN) boot_build/ocamlopt
	$(MAKE) -C stdlib byte/std_exit.cmx

stdlib/byte/libasmrun.a: asmrun/libasmrun.a
	$(MAKE) -C stdlib byte
	cp asmrun/libasmrun.a stdlib/byte/libasmrun.a


byte_depend: beforedepend
	(for d in utils parsing typing bytecomp asmcomp \
	          asmcomp/byte driver toplevel tools; \
	 do $(CAMLDEP) -prefix byte $(DEPFLAGS) -I asmcomp/byte $$d/*.mli $$d/*.ml; \
	 done) > .byte_depend
