
opt/%.cmi: %.mli
	$(OPT_CAMLC) $(OPT_COMPFLAGS) -o $@ -c $<

opt/%.cmo: %.ml
	$(OPT_CAMLC) $(OPT_COMPFLAGS) -o $@ -c $<

opt/%.cmx: %.ml
	$(OPT_CAMLOPT) $(OPT_COMPFLAGS) -o $@ -c $<

asmcomp/opt:
	mkdir -p $@

asmcomp/opt/%.ml: asmcomp/$(OPT_ARCH)/%.ml | asmcomp/opt
	cp $< $@

asmcomp/opt/%.mli: asmcomp/%.mli | asmcomp/opt
	cp $< $@

asmcomp/opt/%.mlp: asmcomp/$(OPT_ARCH)/%.mlp | asmcomp/opt
	cp $< $@

asmcomp/opt/emit.ml: asmcomp/opt/emit.mlp boot_build/tools/cvt_emit
	$(CAMLRUN) boot_build/tools/cvt_emit < $< > $@ \
	|| { rm -f $@; exit 2; }

opt_arch: $(addprefix asmcomp/opt/, \
	arch.ml emit.ml emit.mli proc.ml proc.mli selection.ml selection.mli \
	reload.ml reload.mli scheduling.ml scheduling.mli )

partialclean::
	rm -rf asmcomp/opt

beforedepend:: opt_arch

.PHONY: opt_arch

$(OPT_ALL) $(OPT_ALL:.cmo=.cmi): stdlib/opt/stdlib.cma
$(OPT_ALL:.cmo=.cmx): stdlib/opt/stdlib.cmxa

opt/compilerlibs/ocamlcommon.cma: $(OPT_COMMON) | opt/compilerlibs
	$(OPT_CAMLC) -a -o $@ $(OPT_COMMON)

opt/compilerlibs/ocamlcommon.cmxa: $(OPT_COMMON:.cmo=.cmx) | opt/compilerlibs
	$(OPT_CAMLOPT) -a -o $@ $(OPT_COMMON:.cmo=.cmx)


opt/compilerlibs/ocamlbytecomp.cma: $(OPT_BYTECOMP) | opt/compilerlibs
	$(OPT_CAMLC) -a -o $@ $(OPT_BYTECOMP)

opt/compilerlibs/ocamlbytecomp.cmxa: $(OPT_BYTECOMP:.cmo=.cmx) | opt/compilerlibs
	$(OPT_CAMLOPT) -a -o $@ $(OPT_BYTECOMP:.cmo=.cmx)


opt/compilerlibs/ocamltoplevel.cma: $(OPT_TOPLEVEL) | opt/compilerlibs
	$(OPT_CAMLC) -a -o $@ $(OPT_TOPLEVEL)

opt/compilerlibs/ocamltoplevel.cmxa: $(OPT_TOPLEVEL:.cmo=.cmx) | opt/compilerlibs
	$(OPT_CAMLOPT) -a -o $@ $(OPT_TOPLEVEL:.cmo=.cmx)


opt/compilerlibs/ocamloptcomp.cma: $(OPT_ASMCOMP) | opt/compilerlibs
	$(OPT_CAMLC) -a -o $@ $(OPT_ASMCOMP)

opt/compilerlibs/ocamloptcomp.cmxa: $(OPT_ASMCOMP:.cmo=.cmx) | opt/compilerlibs
	$(OPT_CAMLOPT) -a -o $@ $(OPT_ASMCOMP:.cmo=.cmx)


opt/ocamlc.opt: opt/compilerlibs/ocamlcommon.cmxa \
	         opt/compilerlibs/ocamlbytecomp.cmxa \
	         $(OPT_BYTESTART:.cmo=.cmx) stdlib/opt/std_exit.cmx \
	         asmrun/libasmrun.a
	$(OPT_CAMLOPT) $(LINKFLAGS) -o $@ \
	   opt/compilerlibs/ocamlcommon.cmxa \
	   opt/compilerlibs/ocamlbytecomp.cmxa \
	   $(OPT_BYTESTART:.cmo=.cmx)

opt/ocamlopt.opt: opt/compilerlibs/ocamlcommon.cmxa \
	           opt/compilerlibs/ocamloptcomp.cmxa \
	           $(OPT_OPTSTART:.cmo=.cmx) stdlib/opt/std_exit.cmx \
	           asmrun/libasmrun.a
	$(OPT_CAMLOPT) $(LINKFLAGS) -o $@ \
	   opt/compilerlibs/ocamlcommon.cmxa \
	   opt/compilerlibs/ocamloptcomp.cmxa \
	   $(OPT_OPTSTART:.cmo=.cmx)

opt/ocamlc: opt/compilerlibs/ocamlcommon.cma \
	           opt/compilerlibs/ocamlbytecomp.cma \
	           $(OPT_BYTESTART) stdlib/opt/std_exit.cmo
	$(OPT_CAMLC) $(LINKFLAGS) -compat-32 -o $@ \
	   opt/compilerlibs/ocamlcommon.cma \
	   opt/compilerlibs/ocamlbytecomp.cma \
	   $(OPT_BYTESTART)

#FIXME: missing -compat-32
opt/ocamlopt: opt/compilerlibs/ocamlcommon.cma \
	             opt/compilerlibs/ocamloptcomp.cma \
	             $(OPT_OPTSTART) stdlib/opt/std_exit.cmo
	$(OPT_CAMLC) $(LINKFLAGS) -o $@ \
	   opt/compilerlibs/ocamlcommon.cma \
	   opt/compilerlibs/ocamloptcomp.cma \
	   $(OPT_OPTSTART)


stdlib/opt/stdlib.cma: byte/ocamlc.opt
	$(MAKE) -C stdlib opt/stdlib.cma

# Depends on stdlib.cma because .cmi are build using ocamlc maybe add a
# stdlib/all_cmi target that would also allow allow more parallelism
stdlib/opt/stdlib.cmxa: byte/ocamlopt.opt \
                                      stdlib/opt/libasmrun.a \
                                      stdlib/opt/stdlib.cma
	$(MAKE) -C stdlib opt/stdlib.cmxa

stdlib/opt/std_exit.cmo: byte/ocamlc.opt
	$(MAKE) -C stdlib opt/std_exit.cmo

stdlib/opt/std_exit.cmx: byte/ocamlopt.opt
	$(MAKE) -C stdlib opt/std_exit.cmx

stdlib/opt/libasmrun.a: asmrun/libasmrun.a
	$(MAKE) -C stdlib opt
	cp asmrun/libasmrun.a stdlib/opt/libasmrun.a


opt_depend: beforedepend
	(for d in utils parsing typing bytecomp asmcomp \
	          asmcomp/opt driver toplevel tools; \
	 do $(CAMLDEP) -prefix opt $(DEPFLAGS) -I asmcomp/opt $$d/*.mli $$d/*.ml; \
	 done) > .opt_depend
